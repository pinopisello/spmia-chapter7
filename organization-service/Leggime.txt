Esempio organization service con token JWT , non con semplice bearer...



#################  Esempio invocazione #########################
http://localhost:8080/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a

1) Invoco POST http://localhost:8083/auth/oauth/token per ottenere Bearer token.
Ricordo di passare:
  a)Header   Basic ZWFnbGVleWU6dGhpc2lzc2VjcmV0 []
  b)passo nel body POST grant_type=password&scope=webclient&username=john.carnell&password=password1

Ottengo "access_token": "yyz"

2)Invoco http://localhost:8080/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a

Aggiungo header : Bearer xyz 


	ApplicationFilterChain.doFilter() => ApplicationFilterChain.internalDoFilter() => DelegatingFilterProxyRegistrationBean.doFilter() => FilterChainProxy.doFilter() => FilterChainProxy.doFilterInternal() => FilterChainProxy$VirtualFilterChain.doFilter() =>OAuth2AuthenticationProcessingFilter.doFilter() => PreAuthenticatedAuthenticationToken authentication = tokenExtractor.extract(request); authentication.principal contiene il bearer token inviato dal client 
																																																																													OAuth2Authentication auth =OAuth2AuthenticationManager.authenticate(authentication) =>  String token = (String) authentication.getPrincipal(); il token "xyz"																    token="xyz"
																																																																																																			OAuth2Authentication auth =DefaultTokenServices.loadAuthentication(token)=> OAuth2AccessToken accessToken =  JwtTokenStore.readAccessToken(token) =>  OAuth2AccessToken accessToken = JwtTokenStore.convertAccessToken(token) => JwtAccessTokenConverter.decode(token) => Jwt jwt = JwtHelper.decodeAndVerify(token, MacSigner(HMACSHA256)) => JwtImpl jwt = decode(token)  => token= header_b64 . claims_b64 . crypto_b64   Vedi JWT_token_decoder per esempio pratico
																																																																																																																																																																																						   								   JwtHeader header = JwtHeaderHelper.create(header_str) => header_b64 , una volta b64 decoded, contiene  json tipo {"alg":"HS256","typ":"JWT"}	
																																																																																																																																																																																						   								   byte[] claims = b64UrlDecode(claims_b64);	
																																																																																																																																																																																						   								   byte[] crypto = b64UrlDecode(crypto_b64s);	  crypto e' HMACSHA256 signature di header.claims (NON b64 encoded)  con SigniningKey "345345fsdfsf5345"
																																																																																																																																																																																						   								   return new JwtImpl(header, claims, crypto) 
																																																																																																			
																																																																																																																																																																					 																		                                                            
																																																																																																																																																																																						   jwt.verifySignature(MacSigner) => byte[] input = signingInput() => return concat(b64UrlEncode(header.bytes()), JwtHelper.PERIOD,b64UrlEncode(content));
																																																																																																																																																																																						   									 input e' header_b64 . claims_b64 , ossia token senza la parte ".crypto_b64"
																																																																																																																																																																																						   									 return MacSigner.verify(input, crypto) =>   byte[] signed = javax.crypto.Mac.sign(input) ritorna signature HMACSHA256 di input usano SigniningKey "345345fsdfsf5345"
																																																																																																																																																																																						   									 																						  che e' settata in JWTTokenStoreConfig.jwtAccessTokenConverter() !!
																																																																																																																																																																																						   									 																						  Stessa chiave e' settata in OAuth server in authenticationservice-prod.yml!!
																																																																																																																																																																																						   									 											  if (!isEqual(signed, crypto)) throw new InvalidSignatureException e tutto si blocca!!
																																																																																																																																																																																						   return jwt		
																																																																																																																																								  return 	accessToken
																																																																																																																																								  																									token = "xyz"
																																																																																																																						OAuth2Authentication result = JwtTokenStore.readAuthentication(accessToken) => JwtTokenStore.readAuthentication(accessToken.getValue()) => Map decoded_token_map = JwtAccessTokenConverter.decode(token)  Map contiene entries di token.claims [organizationId,user_name,scope,exp,role,authorities,client_id]
																																																																																																																						return 	result																																   OAuth2Authentication authentication = JwtAccessTokenConverter.extractAuthentication(decoded_token_map) => DefaultAccessTokenConverter.extractAuthentication(decoded_token_map)  => Authentication user =  DefaultUserAuthenticationConverter.extractAuthentication(decoded_token_map) =>  return new UsernamePasswordAuthenticationToken("john.carnell", "N/A", authorities);
																																																																																																			return auth																																																					   																																													  OAuth2Request request = new OAuth2Request(parameters, clientId, authorities, true, scope, resourceIds, null, null)
																																																																													SecurityContextHolder.getContext().setAuthentication(authResult) => SecurityContextImpl.setAuthentication(authResult)
																																																																													Quindi i dati utente contenuti nel token (che e' stato validato!!) sono storati in SecurityContextImpl.authentication !!
																																																																													La filterchain continua verso il target controller....																																																																										   																																													  return new OAuth2Authentication(request, user) //contiene scope,client_id,username,scope estratti dall auth token
																																																																																																																																																								   return authentication																																										  
																																																															FilterSecurityInterceptor.doFilter() =>  FilterInvocation fi = new FilterInvocation(request, response, chain);																																																																																									   																																														
																																																																									 FilterSecurityInterceptor.invoke(fi) =>	InterceptorStatusToken token = super.beforeInvocation(fi) => AbstractSecurityInterceptor.beforeInvocation(fi)	=> Collection<ConfigAttribute> attributes = FilterSecurityInterceptor.obtainSecurityMetadataSource().getAttributes(FilterInvocation) => 	FilterSecurityInterceptor.securityMetadataSource.requestMap  contiene le regole settate in ResourceServerConfiguration.configure()!!																																																																													   																																														
																																																																																																																																																			getAttributes(fi) ritorna la prima entry di tale map che matcha	la request in entrata	.Qui si seleziona quale delle rules settate in ResourceServerConfiguration.configure() va applicata!
																																																																																																																																																					   
																																																																																																																   Authentication authenticated = authenticateIfRequired();  prende quella storata da OAuth2AuthenticationProcessingFilter in SecurityContextImpl.authentication
																																																																																																																   
																																																																																																																   AffirmativeBased.decide(authenticated, FilterInvocation, attributes) =>for (AccessDecisionVoter voter : AffirmativeBased.secisionVoters)    E' qui che le regole di auth (attributes) , la request (FilterInvocation) e i dati authentication da OAuth server vengono comparate per decidere se far passare req verso endpoint o no!!
																																																																																																																   																					int result = WebExpressionVoter.vote(authenticated, FilterInvocation, attributes) =>    WebExpressionConfigAttribute weca = WebExpressionVoter.findConfigAttribute(attributes)                           Ritorna primo attribute che e' instanza WebExpressionConfigAttribute.weca  deriva da ResourceServerConfiguration.configure!! [#oauth2.throwOnError(authenticated)]
																																																																																																																   																																											EvaluationContext ctx = expressionHandler.createEvaluationContext(authenticated,FilterInvocation); ctx deriva da request (FilterInvocation) e da OAuth2 server(authenticateds)
																																																																																																																   																																											boolean pass = ExpressionUtils.evaluateAsBoolean(weca.getAuthorizeExpression(), ctx)               Qui request, config e authorization si confrontano!! weca.getAuthorizeExpression()="#oauth2.throwOnError(authenticated)"
																																																																															    																																						   																																						return pass
																																																																														    																																						   																Se result e' 1, la request prosegue verso controller.
																																																																														    																																						   																altrimenti eccezzione e response e' 401!!
																																																																															    																																						   																
																																																																															    																																						   																
Tutto dipende dal risultato boolean pass = ExpressionUtils.evaluateAsBoolean(weca.getAuthorizeExpression(), ctx) => ((Boolean) expr.getValue(ctx, Boolean.class)).booleanValue()


weca.getAuthorizeExpression()	 e' SpelExpression. "#oauth2.throwOnError(authenticated)"
ctx e' StandardEvaluationContext

https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html

Una SpelExpression funziona usando construtti/variabili definiti in un context.

Nel caso in questione :

    	 http
        .authorizeRequests()
          .antMatchers(HttpMethod.DELETE, "/v1/organizations/**")
          .hasRole("ADMIN")
          .anyRequest()
          .authenticated();
          
Genera due entries in FilterSecurityInterceptor.securityMetadataSource.requestMap:

   key																value(WebExpressionConfigAttribute)
1)AntPathRequestMatcher[pattern='/v1/organizations/**', DELETE] => [#oauth2.throwOnError(hasRole('ROLE_ADMIN'))]

2)AnyRequestMatcher												=> [#oauth2.throwOnError(authenticated)]


Queste vengolo comparate con request in FilterSecurityInterceptor.obtainSecurityMetadataSource().getAttributes(FilterInvocation) in quell ordine!!

Se provo ad invocare GET http://localhost:8080/v1/organizations/e254f8c-c442-4ebe-a82a-e2fc1d1ff78a con bearer ottenuto da john.carnell , la seconda regolaviene matchata e la req passa.
Se riperto con DELETE fallisce perche carnell NON E' ADMIN, e' ROLE_USER.
Se cambio ROLE in ADMIN in auth server, la delete funziona!!

Ma che oggetto ha metodo hasRole()?
Chi e' #oauth2.throwOnError??

In WebExpressionVoter.vote()
EvaluationContext ctx = OAuth2WebSecurityExpressionHandler.createEvaluationContext(authentication,fi); =>   WebSecurityExpressionRoot root = createSecurityExpressionRoot(authentication,invocation);
																											StandardEvaluationContext ctx = OAuth2WebSecurityExpressionHandler.createEvaluationContextInternal(authentication,invocation) => 	StandardEvaluationContext ec = super.createEvaluationContextInternal(authentication, invocation);
																																																												ec.setVariable("oauth2", new OAuth2SecurityExpressionMethods(authentication));
																																																												return ec;
																											ctx.setRootObject(root);
																											return ctx;
Quindi isAuthenticated() appartiene a WebSecurityExpressionRoot!!Quello e' il root object del context.
Inoltre, vedi su, OAuth2SecurityExpressionMethods e' linkato oggetto chiamato "oauth2".

Nell esecuzione SpelExpression hasRole() viene eseguito e il result viene passato a OAuth2SecurityExpressionMethods.throwOnError()!!

Il risultato e' passato a AffirmativeBased.vote() che decide se throw una exception o permetterre alla request di raggiundere il controller target.





																																																																										    																																						   
																																																																											    
																																																																											    
																																																																																																																   																																											
																																																																																																			
																																																																																																			